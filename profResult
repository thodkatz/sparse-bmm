--------------------------------------------------------------------------------
Profile data file 'callgrind.out.263322' (creator: callgrind-3.17.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 106435668167
Trigger: Program termination
Profiled target:  ./bin/serial matrices/pli/pli.mtx (PID 263322, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                       
--------------------------------------------------------------------------------
392,359,357,308 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                        file:function
--------------------------------------------------------------------------------
263,733,302,897 (67.22%)  src/spgemm.cpp:csxMul(CSX const&, CSX const&) [/home/tkatz/repos/sparse-bmm/bin/serial]
120,634,123,162 (30.75%)  src/sparsetools.cpp:csr2bcsr(MatrixInfo&, CSX const&, CSX&) [/home/tkatz/repos/sparse-bmm/bin/serial]
  2,082,693,044 ( 0.53%)  ???:__memset_avx2_unaligned_erms [/usr/lib/libc-2.33.so]
  2,060,342,930 ( 0.53%)  /usr/include/c++/11.1.0/bits/stl_vector.h:csr2bcsr(MatrixInfo&, CSX const&, CSX&)

--------------------------------------------------------------------------------
-- Auto-annotated source: src/sparsetools.cpp
--------------------------------------------------------------------------------
Ir                      

-- line 3 ----------------------------------------
             .           #include "mmio.hpp"
             .           #include "utils.hpp"
             .           
             .           /**
             .            * Source:
             .            * https://math.nist.gov/MatrixMarket/mmio-c.html
             .            */
             .           void mm2coo(int argc, char* argv, std::vector<uint32_t>& cooRows, std::vector<uint32_t>& cooCols, MatrixInfo& arr)
            34 ( 0.00%)  {
           102 ( 0.00%)  => ???:mcount (2x)
             .               uint32_t& nRow = arr.nRow;
             2 ( 0.00%)      uint32_t& nCol = arr.nCol;
             2 ( 0.00%)      uint32_t& nnz  = arr.nnz;
             .           
             .               MM_typecode matcode;
             .               FILE* f;
             .           
             .               // expecting a filename to read (./main <filename>)
             4 ( 0.00%)      if (argc < 2) {
             .                   printf("Missed command line arguements\n");
             .                   fprintf(stderr, "Usage: ./bin [martix-market-filename]\n");
             .                   exit(1);
             .               }
             .               else {
            16 ( 0.00%)          if ((f = fopen(argv, "r")) == NULL) {
           768 ( 0.00%)  => ???:_dl_runtime_resolve_xsave (1x)
         1,066 ( 0.00%)  => ???:fopen@@GLIBC_2.2.5 (2x)
             .                       printf("Can't open file\n");
             .                       exit(1);
             .                   }
             .               }
             .           
            12 ( 0.00%)      if (mm_read_banner(f, &matcode) != 0) {
        10,355 ( 0.00%)  => /home/tkatz/repos/sparse-bmm/src/mmio.cpp:mm_read_banner(_IO_FILE*, char (*) [4]) (2x)
             .                   printf("Could not process Matrix Market banner.\n");
             .                   exit(1);
             .               }
             .           
             .               // what MM formats do you support?
            12 ( 0.00%)      if (!(mm_is_matrix(matcode) && mm_is_coordinate(matcode) && mm_is_pattern(matcode))) {
             .                   printf("Sorry, this application does not support ");
             .                   printf("Matrix Market type: [%s]\n", mm_typecode_to_str(matcode));
             .                   exit(1);
             .               }
             .           
             .               /* find out size of sparse matrix .... */
            14 ( 0.00%)      if ((mm_read_mtx_crd_size(f, &nRow, &nCol, &nnz)) != 0)
        10,788 ( 0.00%)  => /home/tkatz/repos/sparse-bmm/src/mmio.cpp:mm_read_mtx_crd_size(_IO_FILE*, unsigned int*, unsigned int*, unsigned int*) (2x)
             .                   exit(1);
             .           
             4 ( 0.00%)      cooRows.resize(nnz);
             6 ( 0.00%)      cooCols.resize(nnz);
             .           
             2 ( 0.00%)      uint32_t x, y = 0;
     4,119,028 ( 0.00%)      for (uint32_t i = 0; i < nnz; i++) {
     9,611,032 ( 0.00%)          fscanf(f, "%u %u\n", &x, &y);
 1,925,425,736 ( 0.49%)  => ???:__isoc99_fscanf (1,373,004x)
           854 ( 0.00%)  => ???:_dl_runtime_resolve_xsave (1x)
     4,119,012 ( 0.00%)          cooRows[i] = x;
     2,746,008 ( 0.00%)          cooCols[i] = y;
             .                   /* adjust from 1-based to 0-based */
     1,373,004 ( 0.00%)          cooRows[i]--;
     1,373,004 ( 0.00%)          cooCols[i]--;
             .               }
             .           
            10 ( 0.00%)      printf("Success, MM format is converted to COO\n");
         3,308 ( 0.00%)  => ???:puts (2x)
           767 ( 0.00%)  => ???:_dl_runtime_resolve_xsave (1x)
             .           
             4 ( 0.00%)      if (f != stdin) {
            10 ( 0.00%)          fclose(f);
           808 ( 0.00%)  => ???:_dl_runtime_resolve_xsave (1x)
         1,086 ( 0.00%)  => ???:fclose@@GLIBC_2.2.5 (2x)
             .               }
            22 ( 0.00%)  }
             .           
             .           /*
             .            * Source:
             .            * https://github.com/scipy/scipy/blob/master/scipy/sparse/sparsetools/coo.h
             .            *
             .            * Compute B = A for COO matrix A, CSR matrix B
             .            *
             .            * Input Arguments:
-- line 74 ----------------------------------------
-- line 94 ----------------------------------------
             .            *
             .            *   Complexity: Linear.  Specifically O(nnz(A) + max(n_row,n_col))
             .            *
             .            */
             .           void coo2csr(const MatrixInfo& arr,
             .                        const std::vector<uint32_t>& cooRows,
             .                        const std::vector<uint32_t>& cooCols,
             .                        CSX& csr)
            22 ( 0.00%)  {
           102 ( 0.00%)  => ???:mcount (2x)
             .               const uint32_t& nRow = arr.nRow;
             .               const uint32_t& nnz  = arr.nnz;
             .           
             2 ( 0.00%)      std::vector<uint32_t>& csrRow = csr.pointer;
             2 ( 0.00%)      std::vector<uint32_t>& csrCol = csr.indices;
             .           
             .               // compute number of non-zero entries per row of A
             4 ( 0.00%)      csrRow.resize(nRow + 1);
             4 ( 0.00%)      csrCol.resize(nnz);
             .           
     5,492,024 ( 0.00%)      for (uint32_t i = 0; i < nnz; i++) {
     4,119,012 ( 0.00%)          csrRow[cooRows[i]]++;
             .               }
             .           
             .               // cumsum the nnz per row to get rowPointer[]
       181,572 ( 0.00%)      for (uint32_t i = 0, cumsum = 0; i < nRow; i++) {
        90,780 ( 0.00%)          uint32_t temp = csrRow[i];
        45,390 ( 0.00%)          csrRow[i]     = cumsum;
        45,390 ( 0.00%)          cumsum += temp;
             .               }
             4 ( 0.00%)      csrRow[nRow] = nnz;
             .           
             .               // write cooCols,Ax into colIndices,Bx
     4,119,018 ( 0.00%)      for (uint32_t i = 0; i < nnz; i++) {
     1,373,004 ( 0.00%)          uint32_t row  = cooRows[i];
     1,373,004 ( 0.00%)          uint32_t dest = csrRow[row];
             .           
     4,119,012 ( 0.00%)          csrCol[dest] = cooCols[i];
     1,373,004 ( 0.00%)          csrRow[row]++;
             .               }
             .           
       136,182 ( 0.00%)      for (uint32_t i = 0, last = 0; i <= nRow; i++) {
       136,176 ( 0.00%)          uint32_t temp = csrRow[i];
        45,392 ( 0.00%)          csrRow[i]     = last;
             .                   last          = temp;
             .               }
             .           
             .               // now Bp,Bj,Bx form a CSR representation (with possible duplicates)
            12 ( 0.00%)  }
             .           
             .           /**
             .            * Source:
             .            * https://github.com/scipy/scipy/blob/3b36a57/scipy/sparse/sparsetools/coo.h#L34
             .            */
             .           void coo2csc(const MatrixInfo& arr,
             .                        const std::vector<uint32_t>& cooRows,
             .                        const std::vector<uint32_t>& cooCols,
             .                        CSX& csc)
             .           {
             4 ( 0.00%)      MatrixInfo swapArr;
             2 ( 0.00%)      swapArr.nRow = arr.nCol;
             .               swapArr.nRow = arr.nCol;
             2 ( 0.00%)      swapArr.nnz  = arr.nnz;
             5 ( 0.00%)      coo2csr(swapArr, cooCols, cooRows, csc);
    14,894,383 ( 0.00%)  => src/sparsetools.cpp:coo2csr(MatrixInfo const&, std::vector<unsigned int, std::allocator<unsigned int> > const&, std::vector<unsigned int, std::allocator<unsigned int> > const&, CSX&) (1x)
             .           }
             .           
             .           /**
             .            * Convert csr to its blocked version
             .            * TODO: Explain the blocking
             .            */
             .           void csr2bcsr(MatrixInfo& arr, const CSX& csr, CSX& bcsr)
            24 ( 0.00%)  {
            62 ( 0.00%)  => ???:mcount (2x)
             .               const uint32_t& nRow       = arr.nRow;
             .               const uint32_t& nCol       = arr.nCol;
             .               const uint32_t& nnz        = arr.nnz;
             .               const uint32_t& blockSizeX = arr.blockSizeX;
             .               const uint32_t& blockSizeY = arr.blockSizeY;
             .               uint32_t& numBlockX        = arr.numBlockX;
             .               uint32_t& numBlockY        = arr.numBlockY;
             .           
             .               const std::vector<uint32_t>& csrRow  = csr.pointer;
             .               const std::vector<uint32_t>& csrCol  = csr.indices;
             2 ( 0.00%)      std::vector<uint32_t>& bcsrRow = bcsr.pointer;
             2 ( 0.00%)      std::vector<uint32_t>& bcsrCol = bcsr.indices;
             .           
            16 ( 0.00%)      if (nCol / blockSizeX == 0 || nRow / blockSizeY == 0) {
             .                   std::cout << "Block dimensions exceed the matrix dimensions" << std::endl;
             .                   exit(-1);
             .               }
            14 ( 0.00%)      numBlockX            = (nCol % blockSizeX != 0) ? nCol / blockSizeX + 1 : nCol / blockSizeX;
            10 ( 0.00%)      numBlockY            = (nRow % blockSizeY != 0) ? nRow / blockSizeY + 1 : nRow / blockSizeY;
             .               uint32_t totalBlocks = numBlockX * numBlockY;
             .           
             8 ( 0.00%)      bcsrRow.resize(totalBlocks * blockSizeY + 1);
             2 ( 0.00%)      bcsrCol.resize(nnz);
             .           
             2 ( 0.00%)      bcsrRow[0]            = 0;
             2 ( 0.00%)      uint32_t nnzBlocks    = 0;
             .               uint32_t currentBlock = 0;
       113,488 ( 0.00%)      for (uint32_t blockY = 0; blockY < numBlockY; blockY++) {
 1,287,907,218 ( 0.33%)          for (uint32_t blockX = 0; blockX < numBlockX; blockX++) {
 4,635,998,440 ( 1.18%)              for (uint32_t i = blockY * blockSizeY, blockRow = 0; i < (blockY + 1) * blockSizeY; i++, blockRow++) {
 1,545,325,248 ( 0.39%)                  currentBlock = blockY * numBlockX + blockX;
             .           
             .                           // padding when out of bounds
 1,545,325,248 ( 0.39%)                  if (i >= nRow) {
       113,480 ( 0.00%)                      bcsrRow[currentBlock * blockSizeY + blockRow + 1] = nnzBlocks;
             .                               continue;
             .                           }
             .           
             .                           // find the column elements of (blockx,blocky) for blockRow
29,048,717,467 ( 7.40%)                  for (uint32_t j = csrRow[i]; j < csrRow[i + 1]; j++) {
53,517,763,302 (13.64%)                      if (csrCol[j] >= (blockX + 1) * blockSizeX)
             .                                   break;
25,956,852,837 ( 6.62%)                      if (blockX * blockSizeX <= csrCol[j]) {
     5,492,016 ( 0.00%)                          bcsrCol[nnzBlocks++] = csrCol[j];
             .                               }
             .                           }
             .           
 3,090,514,320 ( 0.79%)                  bcsrRow[currentBlock * blockSizeY + blockRow + 1] = nnzBlocks;
             .                       }
             .                   }
             .               }
            16 ( 0.00%)  }
             .           
             .           /**
             .            * Convert csr to its blocked version
             .            * TODO: Explain the blocking
             .            */
             .           void csc2bcsc(const MatrixInfo& arr, const CSX& csc, CSX& bcsc)
             .           {
             .               MatrixInfo swapArr;
-- line 224 ----------------------------------------
-- line 236 ----------------------------------------
             .           /**
             .            * Convert bcsr or bcsc to its non-blocked version
             .            *
             .            * Note:
             .            * - Assumed that the bloking versions was created by \p csx2bcsx()
             .            */
             .           
             .           void mm2csr(char argc, char* argv, CSX& csr, MatrixInfo& arr)
            13 ( 0.00%)  {
            31 ( 0.00%)  => ???:mcount (1x)
             .               std::vector<uint32_t> cooRows;
             .               std::vector<uint32_t> cooCols;
             7 ( 0.00%)      mm2coo(argc, argv, cooRows, cooCols, arr);
   984,015,918 ( 0.25%)  => src/sparsetools.cpp:mm2coo(int, char*, std::vector<unsigned int, std::allocator<unsigned int> >&, std::vector<unsigned int, std::allocator<unsigned int> >&, MatrixInfo&) (1x)
             5 ( 0.00%)      coo2csr(arr, cooRows, cooCols, csr);
    14,894,304 ( 0.00%)  => src/sparsetools.cpp:coo2csr(MatrixInfo const&, std::vector<unsigned int, std::allocator<unsigned int> > const&, std::vector<unsigned int, std::allocator<unsigned int> > const&, CSX&) (1x)
             6 ( 0.00%)  }
             .           
             .           void mm2csc(char argc, char* argv, CSX& csc, MatrixInfo& arr)
            13 ( 0.00%)  {
            31 ( 0.00%)  => ???:mcount (1x)
             .               std::vector<uint32_t> cooRows;
             .               std::vector<uint32_t> cooCols;
             7 ( 0.00%)      mm2coo(argc, argv, cooRows, cooCols, arr);
   984,006,492 ( 0.25%)  => src/sparsetools.cpp:mm2coo(int, char*, std::vector<unsigned int, std::allocator<unsigned int> >&, std::vector<unsigned int, std::allocator<unsigned int> >&, MatrixInfo&) (1x)
             .               coo2csc(arr, cooRows, cooCols, csc);
            14 ( 0.00%)  }            59 ( 0.00%)  => ???:mcount (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: src/spgemm.cpp
--------------------------------------------------------------------------------
Ir                       

-- line 7 ----------------------------------------
              .               mulResult.n = csr.n;
              .               uint32_t rows = csr.n-1;
              .           
              .               mulResult.pointer.resize(mulResult.n);
              .               mulResult.pointer.push_back(0);
              .               for (uint32_t i = 0, idxCol = 0, idxRow = 0; i < rows; i++) {
              .                   for (uint32_t j = 0; j < rows; j++) {
              .                       idxCol = csr.pointer[i];
             16 ( 0.00%)              idxRow = csc.pointer[j];
             31 ( 0.00%)  => ???:mcount (1x)
              .                       if (idxCol == csr.pointer[i + 1]) {
              2 ( 0.00%)                  break;
              1 ( 0.00%)              }
              .           
              .                       // find common elements row ith and column ith (sorted)
              3 ( 0.00%)              while (idxCol < csr.pointer[i + 1] && idxRow < csc.pointer[j + 1]) {
        366,096 ( 0.00%)  => /usr/include/c++/11.1.0/bits/vector.tcc:std::vector<unsigned int, std::allocator<unsigned int> >::operator=(std::vector<unsigned int, std::allocator<unsigned int> > const&) [clone .isra.0] (1x)
              3 ( 0.00%)                  if (csr.indices[idxCol] == csc.indices[idxRow]) {
        365,042 ( 0.00%)  => /usr/include/c++/11.1.0/bits/vector.tcc:std::vector<unsigned int, std::allocator<unsigned int> >::operator=(std::vector<unsigned int, std::allocator<unsigned int> > const&) [clone .isra.0] (1x)
              .                               mulResult.indices.push_back(j);
              .                               mulResult.nnz++;
              3 ( 0.00%)                      break;
         91,163 ( 0.00%)  => /usr/include/c++/11.1.0/bits/vector.tcc:std::vector<unsigned int, std::allocator<unsigned int> >::operator=(std::vector<unsigned int, std::allocator<unsigned int> > const&) [clone .isra.0] (1x)
              3 ( 0.00%)                  }
         91,449 ( 0.00%)  => /usr/include/c++/11.1.0/bits/vector.tcc:std::vector<unsigned int, std::allocator<unsigned int> >::operator=(std::vector<unsigned int, std::allocator<unsigned int> > const&) [clone .isra.0] (1x)
              .                           if (csr.indices[idxCol] > csc.indices[idxRow]) {
              1 ( 0.00%)                      idxRow++;
              1 ( 0.00%)                  }
         90,788 ( 0.00%)                  if (csr.indices[idxCol] < csc.indices[idxRow]) {
  3,100,363,539 ( 0.79%)                      idxCol++;
              .                           }
              .                       }
              .                   }
    515,063,025 ( 0.13%)          mulResult.pointer[i+1] = mulResult.nnz;
  1,030,126,050 ( 0.26%)      }
              .           
              .               return mulResult;
              .           }
 73,737,812,524 (18.79%)  <bogus line 41>
106,818,038,634 (27.22%)  <bogus line 42>
      3,313,334 ( 0.00%)  <bogus line 44>
 17,799,693,105 ( 4.54%)  <bogus line 47>
 16,752,883,242 ( 4.27%)  <bogus line 48>
  8,376,441,621 ( 2.13%)  <bogus line 50>
 35,599,386,210 ( 9.07%)  <bogus line 51>
         90,780 ( 0.00%)  <bogus line 55>
             12 ( 0.00%)  <bogus line 59>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@
@@ Information recorded about lines past the end of 'src/spgemm.cpp'.
@@
@@ Probable cause and solution:
@@ cause:    not sure, sorry
@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11.1.0/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                     

-- line 89 ----------------------------------------
            .                  	pointer;
            .           
            .                 struct _Vector_impl_data
            .                 {
            .           	pointer _M_start;
            .           	pointer _M_finish;
            .           	pointer _M_end_of_storage;
            .           
            1 ( 0.00%)  	_Vector_impl_data() _GLIBCXX_NOEXCEPT
           40 ( 0.00%)  	: _M_start(), _M_finish(), _M_end_of_storage()
            .           	{ }
            .           
            .           #if __cplusplus >= 201103L
            .           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
            .           	: _M_start(__x._M_start), _M_finish(__x._M_finish),
            .           	  _M_end_of_storage(__x._M_end_of_storage)
            .           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
            .           #endif
            .           
            .           	void
            .           	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
            .           	{
           10 ( 0.00%)  	  _M_start = __x._M_start;
            .           	  _M_finish = __x._M_finish;
            8 ( 0.00%)  	  _M_end_of_storage = __x._M_end_of_storage;
            .           	}
            .           
            .           	void
            .           	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
            .           	{
            .           	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
            .           	  // information used by TBAA.
            .           	  _Vector_impl_data __tmp;
-- line 121 ----------------------------------------
-- line 328 ----------------------------------------
            .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
            .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
            .                 { }
            .           #endif
            .           
            .                 ~_Vector_base() _GLIBCXX_NOEXCEPT
            .                 {
            .           	_M_deallocate(_M_impl._M_start,
           36 ( 0.00%)  		      _M_impl._M_end_of_storage - _M_impl._M_start);
            .                 }
            .           
            .               public:
            .                 _Vector_impl _M_impl;
            .           
            .                 pointer
            .                 _M_allocate(size_t __n)
            .                 {
            .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
           82 ( 0.00%)  	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
            .                 }
            .           
            .                 void
            .                 _M_deallocate(pointer __p, size_t __n)
            .                 {
            .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
           79 ( 0.00%)  	if (__p)
            .           	  _Tr::deallocate(_M_impl, __p, __n);
            .                 }
            .           
            .               protected:
            .                 void
            .                 _M_create_storage(size_t __n)
            .                 {
            .           	this->_M_impl._M_start = this->_M_allocate(__n);
-- line 361 ----------------------------------------
-- line 672 ----------------------------------------
            .                 /**
            .                  *  The dtor only erases the elements, and note that if the
            .                  *  elements themselves are pointers, the pointed-to memory is
            .                  *  not touched in any way.  Managing the pointer is the user's
            .                  *  responsibility.
            .                  */
            .                 ~vector() _GLIBCXX_NOEXCEPT
            .                 {
           21 ( 0.00%)  	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
            .           		      _M_get_Tp_allocator());
            .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
            .                 }
            .           
            .                 /**
            .                  *  @brief  %Vector assignment operator.
            .                  *  @param  __x  A %vector of identical element and allocator types.
            .                  *
-- line 688 ----------------------------------------
-- line 911 ----------------------------------------
            .                 crend() const noexcept
            .                 { return const_reverse_iterator(begin()); }
            .           #endif
            .           
            .                 // [23.2.4.2] capacity
            .                 /**  Returns the number of elements in the %vector.  */
            .                 size_type
            .                 size() const _GLIBCXX_NOEXCEPT
          283 ( 0.00%)        { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
            .           
            .                 /**  Returns the size() of the largest possible %vector.  */
            .                 size_type
            .                 max_size() const _GLIBCXX_NOEXCEPT
            .                 { return _S_max_size(_M_get_Tp_allocator()); }
            .           
            .           #if __cplusplus >= 201103L
            .                 /**
-- line 927 ----------------------------------------
-- line 931 ----------------------------------------
            .                  *  This function will %resize the %vector to the specified
            .                  *  number of elements.  If the number is smaller than the
            .                  *  %vector's current size the %vector is truncated, otherwise
            .                  *  default constructed elements are appended.
            .                  */
            .                 void
            .                 resize(size_type __new_size)
            .                 {
           26 ( 0.00%)  	if (__new_size > size())
           46 ( 0.00%)  	  _M_default_append(__new_size - size());
       91,231 ( 0.00%)  => /usr/include/c++/11.1.0/bits/vector.tcc:std::vector<unsigned int, std::allocator<unsigned int> >::_M_default_append(unsigned long) (1x)
            .           	else if (__new_size < size())
            .           	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
            .                 }
            .           
            .                 /**
            .                  *  @brief  Resizes the %vector to the specified number of elements.
            .                  *  @param  __new_size  Number of elements the %vector should contain.
            .                  *  @param  __x  Data with which new elements should be populated.
-- line 948 ----------------------------------------
-- line 992 ----------------------------------------
            .           
            .                 /**
            .                  *  Returns the total number of elements that the %vector can
            .                  *  hold before needing to allocate more memory.
            .                  */
            .                 size_type
            .                 capacity() const _GLIBCXX_NOEXCEPT
            .                 { return size_type(this->_M_impl._M_end_of_storage
           12 ( 0.00%)  			 - this->_M_impl._M_start); }
            .           
            .                 /**
            .                  *  Returns true if the %vector is empty.  (Thus begin() would
            .                  *  equal end().)
            .                  */
            .                 _GLIBCXX_NODISCARD bool
            .                 empty() const _GLIBCXX_NOEXCEPT
            .                 { return begin() == end(); }
-- line 1008 ----------------------------------------
-- line 1038 ----------------------------------------
            .                  *  Note that data access with this operator is unchecked and
            .                  *  out_of_range lookups are not defined. (For checked lookups
            .                  *  see at().)
            .                  */
            .                 reference
            .                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
            .                 {
            .           	__glibcxx_requires_subscript(__n);
    9,701,820 ( 0.00%)  	return *(this->_M_impl._M_start + __n);
            .                 }
            .           
            .                 /**
            .                  *  @brief  Subscript access to the data contained in the %vector.
            .                  *  @param __n The index of the element for which data should be
            .                  *  accessed.
            .                  *  @return  Read-only (constant) reference to data.
            .                  *
-- line 1054 ----------------------------------------
-- line 1056 ----------------------------------------
            .                  *  Note that data access with this operator is unchecked and
            .                  *  out_of_range lookups are not defined. (For checked lookups
            .                  *  see at().)
            .                  */
            .                 const_reference
            .                 operator[](size_type __n) const _GLIBCXX_NOEXCEPT
            .                 {
            .           	__glibcxx_requires_subscript(__n);
2,060,342,890 ( 0.53%)  	return *(this->_M_impl._M_start + __n);
            .                 }
            .           
            .               protected:
            .                 /// Safety check used only from at().
            .                 void
            .                 _M_range_check(size_type __n) const
            .                 {
            .           	if (__n >= this->size())
-- line 1072 ----------------------------------------
-- line 1181 ----------------------------------------
            .                  *  element at the end of the %vector and assigns the given data
            .                  *  to it.  Due to the nature of a %vector this operation can be
            .                  *  done in constant time if the %vector has preallocated space
            .                  *  available.
            .                  */
            .                 void
            .                 push_back(const value_type& __x)
            .                 {
    9,940,002 ( 0.00%)  	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
            .           	  {
            .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
            .           	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
            .           				     __x);
    6,626,622 ( 0.00%)  	    ++this->_M_impl._M_finish;
            .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
            .           	  }
            .           	else
            .           	  _M_realloc_insert(end(), __x);
            .                 }
            .           
            .           #if __cplusplus >= 201103L
            .                 void
-- line 1202 ----------------------------------------
-- line 1750 ----------------------------------------
            .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
            .                 { return _M_insert_rval(__position, std::move(__v)); }
            .           #endif
            .           
            .                 // Called by _M_fill_insert, _M_insert_aux etc.
            .                 size_type
            .                 _M_check_len(size_type __n, const char* __s) const
            .                 {
          282 ( 0.00%)  	if (max_size() - size() < __n)
            .           	  __throw_length_error(__N(__s));
            .           
            .           	const size_type __len = size() + (std::max)(size(), __n);
            2 ( 0.00%)  	return (__len < size() || __len > max_size()) ? max_size() : __len;
            .                 }
            .           
            .                 // Called by constructors to check initial size.
            .                 static size_type
            .                 _S_check_init_len(size_type __n, const allocator_type& __a)
            .                 {
            .           	if (__n > _S_max_size(_Tp_alloc_type(__a)))
            .           	  __throw_length_error(
-- line 1770 ----------------------------------------

--------------------------------------------------------------------------------
Ir                       
--------------------------------------------------------------------------------
127,412,369,189 (32.47%)  events annotated

